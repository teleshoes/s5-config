#!/usr/bin/perl
use strict;
use warnings;

my $user = "root"; #note that SimpleSSHD ignores the user
my $ipmagicName = "s5";

my $SD_FAT_UUID = "8D67-6AFB";
my $SNAP_APP_DIR = "Android/data/org.lineageos.snap/files";

my $localDir = "$ENV{HOME}/Code/s5/backup/DCIM";
my @backups = (
  [ $localDir, "/sdcard/DCIM/Camera",                    "int-cam" ],
  [ $localDir, "/sdcard/DCIM/100ANDRO",                  "int-andro" ],
  [ $localDir, "/storage/$SD_FAT_UUID/DCIM/Camera",      "sd-fat" ],
  [ $localDir, "/sdcard/Pictures/Screenshots",           "screenshots" ],
  [ $localDir, "/sdcard/Movies/Screencasts",             "screencasts" ],
  #  [ $localDir, "/sdcard/$SNAP_APP_DIR",                  "int-snap" ],
  #  [ $localDir, "/storage/$SD_FAT_UUID/$SNAP_APP_DIR",    "sd-snap" ],
);

my @filetypes = qw(jpg jpeg png gif mp4);

sub dcimBackup($$$);
sub reorganizeBackedUpRemotes($$$$$);
sub md5sumMaps(\@);
sub runMd5sum($);
sub wrapQuotes($);
sub updateMd5sums($);
sub remoteDirExists($);

sub main(@){
  for my $backup(@backups){
    my ($localDCIM, $remoteDCIM, $backupSuffix) = @$backup;
    dcimBackup($localDCIM, $remoteDCIM, $backupSuffix);
  }
}

sub dcimBackup($$$){
  my ($localDCIM, $remoteDCIM, $backupSuffix) = @_;

  die "local $localDCIM does not exist\n" if not -d $localDCIM;
  die "remote $remoteDCIM does not exist\n" if not remoteDirExists $remoteDCIM;
  chdir $localDCIM;
  print "\n\n===============\n";
  print "Fetching remote md5sums: $remoteDCIM\n";
  my @remoteMd5sums = `ipmagic $ipmagicName -u $user -s md5sum $remoteDCIM/*.* 2>/dev/null`;

  print "===all:\n" . join "", @remoteMd5sums;
  print "===\n\n";

  my $localByMd5sum = updateMd5sums($localDCIM);

  my ($remoteByMd5sum, $remoteByFile) = md5sumMaps @remoteMd5sums;

  my (@backedUp, @needsBackUp);
  for my $md5sum(keys %$remoteByMd5sum){
    my $file = $$remoteByMd5sum{$md5sum};
    if(defined $$localByMd5sum{$md5sum}){
      push @backedUp, $file;
    }else{
      push @needsBackUp, $file;
    }
  }

  reorganizeBackedUpRemotes($remoteDCIM, \@backedUp,
    $localByMd5sum, $remoteByMd5sum, $remoteByFile);

  print "\n\n===NEEDS BACKUP:\n" . join "\n", sort @needsBackUp;
  print "===\n\n";

  if(@needsBackUp > 0){
    my $now = `date +%Y-%m-%d_%s`;
    chomp $now;
    my $dir = "$localDCIM/backup_${now}_${backupSuffix}";
    system "mkdir -p $dir";
    my $host = `ipmagic $ipmagicName`;
    die "could not read ipmagic $ipmagicName hostname\n" if $? != 0;
    chomp $host;

    system "rsync -avP $user\@$host:$remoteDCIM/*.* $dir/";
    die "failed rsync backup\n" if $? != 0;

    print "updating local md5sums again and re-reorganizing remote\n";
    $localByMd5sum = updateMd5sums($localDCIM);

    reorganizeBackedUpRemotes($remoteDCIM, \@needsBackUp,
      $localByMd5sum, $remoteByMd5sum, $remoteByFile);
  }
}

sub reorganizeBackedUpRemotes($$$$$){
  my $remoteDCIM = shift;
  my @backedUpFiles = @{shift()};
  my $localByMd5sum = shift;
  my $remoteByMd5sum = shift;
  my $remoteByFile = shift;

  my %dirsToMake;
  my @mvCmds;
  for my $file(sort @backedUpFiles){
    my $md5sum = $$remoteByFile{$file};
    my $localFile = $$localByMd5sum{$md5sum};
    if(not defined $localFile){
      print "\n\n\n\nSERIOUS ERROR: local backup doesnt exist: $file!\n";
      next;
    }
    my $newRemoteFile = "$remoteDCIM/$localFile";
    my $dir = $newRemoteFile;
    $dir =~ s/\/[^\/]*$//;
    $dir = wrapQuotes $dir;
    $file = wrapQuotes $file;
    $newRemoteFile = wrapQuotes $newRemoteFile;

    $dirsToMake{$dir} = 1;
    push @mvCmds, "mv -n $file $newRemoteFile"
  }
  my $total = @mvCmds;
  print "\n\nReorganizing $total remote files to match local\n";
  if(@mvCmds > 0){
    for my $dir(sort keys %dirsToMake){
      my $mkdirCmd = "mkdir -p $dir";
      system "ipmagic", $ipmagicName, "-u", $user, "-s", $mkdirCmd;
      die "failed to create remote dir $dir\n" if $? != 0;
    }

    my @mvChunks;
    push @mvChunks, [ splice @mvCmds, 0, 10 ] while @mvCmds;
    for my $mvChunk(@mvChunks){
      my $cmdToRun = join " \\\n && ", @$mvChunk;

      my $count = @$mvChunk;
      print "\n\n#running $count mv commands:\n  $cmdToRun\n";

      system "ipmagic", $ipmagicName, "-u", $user, "-s", $cmdToRun;
      my $exitCode = $?;
      die "failed reorganizing remotes (exit=$exitCode)\n" if $exitCode != 0;
    }
  }
}

sub md5sumMaps(\@){
  my %byMd5sum;
  my %byFile;
  my @md5sumLines = @{shift()};
  for my $line(@md5sumLines){
    if($line =~ /^([0-9a-f]{32})  (.+)\n$/){
      $byFile{$2} = $1;
      $byMd5sum{$1} = $2;
    }
  }
  return (\%byMd5sum, \%byFile);
}

sub runMd5sum($){
  my $file = shift;
  $file = wrapQuotes $file;
  my $md5sum = `md5sum $file`;
  die "failed generating md5sum for $file\n" if $? != 0;
  return $md5sum;
}

sub wrapQuotes($){
  my $s = shift;
  $s =~ s/'/'\\''/g;
  $s = "'$s'";
  return $s;
}

sub updateMd5sums($){
  my $localDCIM = shift;
  my @lines = `cat $localDCIM/md5sums`;
  my ($byMd5sum, $byFile) = md5sumMaps @lines;

  my $find = "find -false";
  $find .= " -or -iname '*.$_'" foreach @filetypes;
  my @files = `$find`;
  chomp $_ foreach @files;
  @files = grep {not defined $$byFile{$_}} @files;

  print "md5summing local files\n";
  @lines = map {runMd5sum $_} @files;
  print @lines;

  my ($extraByMd5sum, $extraByFile) = md5sumMaps @lines;
  my %newByMd5sum = (%$byMd5sum, %$extraByMd5sum);
  my %newByFile = (%$byFile, %$extraByFile);

  my $out;
  for my $file(sort keys %newByFile){
    if(-e "$localDCIM/$file"){
      $out .= "$newByFile{$file}  $file\n";
    }else{
      print "removing md5sum for $file\n";
      my $md5 = $newByFile{$file};
      delete $newByFile{$file};
      delete $newByMd5sum{$md5};
    }
  }

  open FH, "> $localDCIM/md5sums";
  print FH $out;
  close FH;

  return \%newByMd5sum;
}

sub remoteDirExists($){
  my ($dir) = @_;
  my $testCmd = "if [ -d \"$dir\" ]; then echo exists; fi";
  my $out = `ipmagic $ipmagicName -u $user -s '$testCmd' 2>/dev/null`;
  if($out =~ /^exists$/){
    return 1;
  }else{
    return 0;
  }
}

&main(@ARGV);
